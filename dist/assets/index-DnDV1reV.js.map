{"version":3,"mappings":"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","names":["hasSymbol","PolySymbol","name","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","isBrowser","isESModule","obj","assign","applyToParams","fn","params","newParams","key","value","noop","TRAILING_SLASH_RE","removeTrailingSlash","path","parseURL","parseQuery","location","currentLocation","query","searchString","hash","searchPos","hashPos","resolveRelativePath","stringifyURL","stringifyQuery","stripBase","pathname","base","isSameRouteLocation","a","b","aLastIndex","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","isSameRouteLocationParamsValue","isEquivalentArray","i","to","from","fromSegments","toSegments","position","toPosition","segment","NavigationType","NavigationDirection","normalizeBase","baseEl","BEFORE_HASH_RE","createHref","getElementPosition","el","offset","docRect","elRect","computeScrollPosition","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getScrollKey","delta","scrollPositions","saveScrollPosition","scrollPosition","getSavedScrollPosition","scroll","createBaseLocation","createCurrentLocation","search","pathFromHash","useHistoryListeners","historyState","replace","listeners","teardowns","pauseState","popStateHandler","state","fromState","listener","pauseListeners","listen","callback","teardown","index","beforeUnloadListener","history","destroy","buildState","back","current","forward","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","err","data","push","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","isRouteLocation","route","isRouteName","START_LOCATION_NORMALIZED","NavigationFailureSymbol","NavigationFailureType","createRouterError","type","isNavigationFailure","error","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","keys","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","subPattern","parse","match","stringify","avoidDuplicatedSlash","param","text","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","message","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","createRouteRecordMatcher","record","parent","parser","matcher","createRouterMatcher","routes","globalOptions","matchers","matcherMap","mergeOptions","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","normalizedRecords","aliases","alias","originalMatcher","normalizedRecord","parentPath","connectingSlash","isAliasRecord","removeRoute","children","insertMatcher","matcherRef","getRoutes","resolve","paramsFromLocation","k","m","matched","parentMatcher","mergeMetaFields","normalizeRecordProps","propsObject","props","meta","defaults","partialOptions","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","commonEncode","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","searchParams","searchParam","eqPos","currentValue","values","v","normalizeQuery","normalizedQuery","useCallbacks","handlers","add","handler","reset","guardToPromiseFn","guard","enterCallbackArray","reject","next","valid","guardReturn","guardCall","extractComponentsGuards","guardType","guards","rawComponent","isRouteComponent","componentPromise","resolved","resolvedComponent","component","useLink","router","inject","currentRoute","computed","unref","activeRecordIndex","length","routeMatched","currentMatched","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","e","guardEvent","RouterLinkImpl","defineComponent","slots","attrs","link","reactive","elClass","getLinkClass","h","RouterLink","target","outer","inner","innerValue","outerValue","propClass","globalClass","defaultClass","RouterViewImpl","injectedRoute","depth","matchedRouteRef","provide","viewRef","ref","watch","instance","oldInstance","oldName","matchedRoute","ViewComponent","currentName","routePropsOption","routeProps","vnode","RouterView","createRouter","parseQuery$1","stringifyQuery$1","scrollBehavior","beforeGuards","beforeResolveGuards","afterGuards","shallowRef","pendingLocation","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","href","matcherLocation","fullPath","locationAsObject","checkCanceledNavigation","pushWithRedirect","redirectedFrom","targetLocation","force","lastMatched","redirect","newTargetLocation","toLocation","failure","handleScroll","triggerError","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","canceledNavigationCheck","runGuardQueue","beforeEnter","isPush","isFirstNavigation","markAsReady","removeHistoryListener","setupListeners","_from","info","readyHandlers","errorHandlers","ready","isReady","nextTick","started","installedApps","app","reactiveRoute","unmountApp","promise","len","recordFrom","recordTo","_imports_0$1","onCroixClick","emit","_imports_0","_imports_1","onMenuClick","sidebarOpen","toggleSidebar","createApp","App","createPinia"],"ignoreList":[0],"sources":["../../node_modules/.pnpm/vue-router@4.0.0-beta.13_vue@3.2.26/node_modules/vue-router/dist/vue-router.esm-bundler.js","../../public/croix.png","../../src/components/sidebar.vue","../../public/menu.png","../../public/logo.png","../../src/components/bandeau.vue","../../src/App.vue","../../src/router/index.ts","../../src/main.ts"],"sourcesContent":["/*!\n  * vue-router v4.0.0-beta.13\n  * (c) 2020 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, warn as warn$1, inject, onUnmounted, onDeactivated, onActivated, computed, unref, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\nconst matchedRouteKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n// rvd = Router View Depth\r\nconst viewDepthKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n// r = router\r\nconst routerKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n// rt = route location\r\nconst routeLocationKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nlet noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    let query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || pathname.toLowerCase().indexOf(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    let aLastIndex = a.matched.length - 1;\r\n    let bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (let key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        let positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    let foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash based url\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        let pathFromHash = hash.slice(1);\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    let currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    let historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        // when the base has a `#`, only use that for the URL\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? base.slice(hashIndex) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/vue-router-next/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (let callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname` or\r\n * `/` if at root. If there is a `base` tag in the `head`, its value will be\r\n * **ignored**.\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (base.indexOf('#') < 0)\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    let score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern = optional ? `(?:/${subPattern})` : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // remove the last slash as we could be at the end\r\n                            if (path.endsWith('/'))\r\n                                path = path.slice(0, -1);\r\n                            // do not append a slash on the next iteration\r\n                            else\r\n                                avoidDuplicatedSlash = true;\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                    customRe = '';\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        let isRootAdd = !originalRecord;\r\n        let mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            let { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                let parentPath = parent.record.path;\r\n                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                let children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            let index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        // console.log('i is', { i })\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0)\r\n            i++;\r\n        // console.log('END i is', { i })\r\n        // while (i < matchers.length && matcher.score <= matchers[i].score) i++\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    let newParams = {};\r\n    for (let key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: [],\r\n        updateGuards: [],\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (let name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    let options = {};\r\n    for (let key in defaults) {\r\n        options[key] =\r\n            key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\nfunction checkSameParams(a, b) {\r\n    for (let key of a.keys) {\r\n        if (!b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (let key of b.keys) {\r\n        if (!a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (let key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\n\n/**\r\n * Encoding Rules  = Space Path:  \" < > # ? { } Query:  \" < > # & = Hash:  \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return commonEncode(text)\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        const searchParam = searchParams[i];\r\n        // allow the = character\r\n        let eqPos = searchParam.indexOf('=');\r\n        let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        if (search.length)\r\n            search += '&';\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined)\r\n                search += key;\r\n            continue;\r\n        }\r\n        // keep null values\r\n        let values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        for (let i = 0; i < values.length; i++) {\r\n            // only append & with i > 0\r\n            search += (i ? '&' : '') + key;\r\n            if (values[i] != null)\r\n                search += ('=' + values[i]);\r\n        }\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (let key in query) {\r\n        let value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(list, guard) {\r\n    const removeFromList = () => {\r\n        const index = list.indexOf(guard);\r\n        if (index > -1)\r\n            list.splice(index, 1);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        const index = list.indexOf(guard);\r\n        if (index < 0)\r\n            list.push(guard);\r\n    });\r\n    list.push(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn$1('onBeforeRouteLeave must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteLeave must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord.leaveGuards, leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn$1('onBeforeRouteUpdate must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteUpdate must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord.updateGuards, updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn$1(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn$1(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn$1(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-ignore: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            // warn if user wrote import('/component.vue') instead of () => import('./component.vue')\r\n            if ((process.env.NODE_ENV !== 'production') && 'then' in rawComponent) {\r\n                warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\"? This will break in production if not fixed.`);\r\n                let promise = rawComponent;\r\n                rawComponent = () => promise;\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                let options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                else {\r\n                    // display the error if any\r\n                    componentPromise = componentPromise.catch((process.env.NODE_ENV !== 'production') ? err => err && warn$1(err) : console.error);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // @ts-ignore: the options types are not propagated to Component\r\n                    const guard = resolvedComponent[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        let { matched } = route.value;\r\n        let { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        let currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        let parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e))\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\r\n        return Promise.resolve();\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    setup(props, { slots, attrs }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', assign({\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    onClick: link.navigate,\r\n                    href: link.href,\r\n                }, attrs, {\r\n                    class: elClass.value,\r\n                }), children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-ignore getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-ignore getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (let key in inner) {\r\n        let innerValue = inner[key];\r\n        let outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nlet getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = defineComponent({\r\n    name: 'RouterView',\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routeLocationKey);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => (props.route || injectedRoute).matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards\r\n                if (from && instance === oldInstance) {\r\n                    to.leaveGuards = from.leaveGuards;\r\n                    to.updateGuards = from.updateGuards;\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = props.route || injectedRoute;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return slots.default\r\n                    ? slots.default({ Component: ViewComponent, route })\r\n                    : null;\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            slots.default\r\n                ? slots.default({ Component: component, route })\r\n                : component);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    let parseQuery$1 = options.parseQuery || parseQuery;\r\n    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    let { scrollBehavior } = options;\r\n    let routerHistory = options.history;\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        let recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            let href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        let href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : rawLocation.query,\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string' ? { path: to } : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const lastMatched = targetLocation.matched[targetLocation.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            // transform it into an object to pass the original RouteLocaleOptions\r\n            let newTargetLocation = locationAsObject(typeof redirect === 'function' ? redirect(targetLocation) : redirect);\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${targetLocation.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                return Promise.reject(new Error('Invalid redirect'));\r\n            }\r\n            return pushWithRedirect(assign({\r\n                query: targetLocation.query,\r\n                hash: targetLocation.hash,\r\n                params: targetLocation.params,\r\n            }, newTargetLocation, {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        }\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a pus\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => {\r\n            if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ |\r\n                8 /* NAVIGATION_CANCELLED */ |\r\n                2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                return error;\r\n            }\r\n            // unknown error, rejects\r\n            return triggerError(error);\r\n        })\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-ignore\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-ignore\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords,] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            for (const guard of record.leaveGuards) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                for (const guard of record.updateGuards) {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && from.matched.indexOf(record) < 0) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            const toLocation = resolve(to);\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // do not restore history on unknown direction\r\n                    if (info.delta)\r\n                        routerHistory.go(-info.delta, false);\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection\r\n                    ).catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure && info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     * @param error - error to throw\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error) {\r\n        markAsReady(error);\r\n        errorHandlers.list().forEach(handler => handler(error));\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    /**\r\n     * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n     * only be called once, otherwise does nothing.\r\n     * @param err - optional error\r\n     */\r\n    function markAsReady(err) {\r\n        if (ready)\r\n            return;\r\n        ready = true;\r\n        setupListeners();\r\n        readyHandlers\r\n            .list()\r\n            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n        readyHandlers.reset();\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(triggerError);\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (let key in START_LOCATION_NORMALIZED) {\r\n                // @ts-ignore: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            let unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                if (installedApps.size < 1) {\r\n                    removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp.call(this, arguments);\r\n            };\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.indexOf(recordFrom) < 0)\r\n                leavingRecords.push(recordFrom);\r\n            else\r\n                updatingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (from.matched.indexOf(recordTo) < 0)\r\n                enteringRecords.push(recordTo);\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, stringifyQuery, useLink, useRoute, useRouter };\n","export default \"__VITE_ASSET__Ds3htT9s__\"","<template>\n  <section :class=\"['sidebar',{'sidebar--open':open}]\">\n    <div id =\"close\" @click=\"onCroixClick\">\n      <img src=\"../../public/croix.png\" alt=\"\">\n    </div>\n\n    <div id = \"choix\">\n      <ul>\n      <li> <RouterLink to=\"/\">Accueil</RouterLink> </li>\n      <li> <RouterLink to=\"/projects\">Projets</RouterLink> </li>\n      <li><RouterLink to=\"/postBac\">Parcours post bac </RouterLink></li>\n      <li> <RouterLink to=\"/pro\">Parcours professionnel </RouterLink></li>\n      </ul>\n    </div>\n  </section>\n</template>\n\n<style lang=\"scss\">\n.sidebar{\n  color:white;\n  position: absolute;\n  top:64px;\n  left: -200px;\n  background-color: #231a15;\n  width: 160px;\n  height: 100%;\n  z-index: 1;\n  transition:left 0.3s;\n\n\n\n  &--open{\n    left: 0;\n    transition:\n        left 0.5s\n  }\n}\n#close{\n  position: absolute;\n  right: 0;\n  top: 0;\n  cursor: pointer;\n\n  &:hover {\n    img {\n      height: 35px;\n      transition:\n          height 0.1s\n    }\n  }\n  img{\n    height: 30px;\n    transition:\n        height 0.1s\n  }\n}\n\n#choix{\n  position: absolute;\n  top: 20px;\n  left: -30px;\n\n}\n\n#choix li{\n\n  text-decoration: none;\n\n  /*&:hover {\n    background-color: rgba(0, 0, 0, 0.3);\n  }*/\n\n  a {\n    text-decoration: none;\n    color: unset;\n  }\n\n  a:visited {\n    color: unset;\n    text-decoration: none;\n  }\n}\n\n#choix li:hover{\n  text-decoration: underline;\n}\n\n#choix ul{\n  list-style-type: none;\n  display:flex;\n  flex-direction: column;\n  justify-content: space-between;\n  row-gap: 20px;\n}\n\n</style>\n\n<script lang=\"ts\" setup>\n  import {RouterLink} from \"vue-router\";\n\n  const props = defineProps({\n    open: Boolean\n  });\n  const emit = defineEmits([\"on-croix-click\"]);\n  function onCroixClick (){\n    emit(\"on-croix-click\");\n  }\n</script>","export default \"__VITE_ASSET__CmFEw119__\"","export default \"__VITE_ASSET__DacSPZ0B__\"","<template>\n  <section class=\"bandeau\">\n    <button @click=\"onMenuClick\" >\n      <img src=\"../../public/menu.png\" alt=\"\">\n      Menu\n    </button>\n    <div class = \"milieu\">\n      <h2>Portefolio</h2>\n      <img src=\"../../public/logo.png\" alt=\"logo\">\n      <h2>Lonorine Tibere</h2>\n    </div>\n\n    <div id = \"contact\">\n      <a href=\"mailto:leonorine.tibere@gmail.com\">Me contacter</a>\n    </div>\n  </section>\n</template>\n<script lang=\"ts\" setup>\n import {FontAwesomeIcon} from \"@fortawesome/vue-fontawesome\";\n const emit = defineEmits([\"on-menu-click\"]);\n function onMenuClick (){\n   emit(\"on-menu-click\");\n }\n</script>\n<style>\n  .bandeau{\n    background-color: #ffffff;\n    box-sizing: border-box;\n    width: 100%;\n    height: 64px;\n    position: relative;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color:#130e05;\n  }\n\n  #contact{\n    margin-right: 2%;\n    min-width: 116px;\n  }\n\n  #contact a{\n    text-decoration: none;\n    color: white;\n    border: solid 2px #B39031;\n    padding: 10px;\n    border-radius: 25px;\n    background-color: #B39031;\n\n  }\n  #contact a:hover{\n    border: solid 2px #130e05;\n  }\n\n  .milieu img{\n    height: 64px;\n\n  }\n\n  .milieu{\n    display: flex;\n    align-items: center;\n\n  }\n\n  button{\n    text-align: center;\n    border: none;\n    background-color: white;\n    font-size: larger;\n    display: flex;\n    align-items: center;\n    margin-left: 5px;\n    margin-right: 10%;\n  }\n\n  button img{\n    height: 15px;\n    margin: 0 3px ;\n  }\n  button:hover{\n    text-decoration: underline;\n  }\n</style>","<script setup lang=\"ts\">\nimport { RouterLink, RouterView } from 'vue-router'\nimport Sidebar from \"@/components/sidebar.vue\";\nimport {ref} from \"vue\";\nimport Bandeau from \"@/components/bandeau.vue\";\nconst sidebarOpen = ref(false);\nfunction toggleSidebar (){\n  sidebarOpen.value = !sidebarOpen.value\n}\n\n\n</script>\n\n<template>\n  <bandeau @on-menu-click=\"toggleSidebar\"/>\n  <sidebar :open=\"sidebarOpen\" @on-croix-click=\"toggleSidebar\"/>\n\n\n\n  <!--  <header>\n     <div class=\"wrapper\">\n--      <nav>\n         <RouterLink to=\"/\">Home</RouterLink>\n         <RouterLink to=\"/about\">About</RouterLink>\n       </nav>\n    </div>\n  </header>-->\n\n  <RouterView />\n</template>\n\n<style scoped>\n\n</style>\n","import { createRouter, createWebHistory } from 'vue-router'\nimport HomeView from '../views/HomeView.vue'\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes: [\n    {\n      path: '/projects',\n      name: 'projects',\n      // route level code-splitting\n      // this generates a separate chunk (About.[hash].js) for this route\n      // which is lazy-loaded when the route is visited.\n      component: () => import('../views/projects.vue')\n    },\n    {\n      path: '/postBac',\n      name: 'Parcours post bac',\n      component: () => import('../views/postBac.vue')\n    },\n    {\n      path: '/pro',\n      name: 'Parcours professionnel',\n      component: () => import('../views/pro.vue')\n    },\n    {\n      path: '/',\n      name: 'Accueil',\n      component: () => import('../views/HomeView.vue')\n    }\n  ]\n})\n\nexport default router\n","import './assets/main.css'\n\nimport { createApp } from 'vue'\n\nimport { createPinia } from 'pinia'\n\n\nimport App from './App.vue'\nimport router from './router'\n\nconst app = createApp(App)\n\napp.use(createPinia())\napp.use(router)\n\napp.mount('#app')\n"],"file":"assets/index-DnDV1reV.js"}